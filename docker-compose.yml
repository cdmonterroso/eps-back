version: '3.8'
# Version de docker compose

services:
  # CONTENEDOR PARA MYSQL
  mysqldb:
    image: mysql:8.0
    container_name: db-sidecc-ddo
    hostname: db-sidecc-ddo
    #restart: always
    env_file:
      - ./.env
    environment:
      - MYSQL_LOCAL_INFILE=1
      - MYSQL_ROOT_PASSWORD=$MYSQLDB_PASSWORD
      - MYSQL_DATABASE=$MYSQLDB_DATABASE
    command:
      - --local-infile=1
    ports:
      # SO ANFITRIÓN : CONTENEDOR
      #- $MYSQLDB_LOCAL_PORT:$MYSQLDB_DOCKER_PORT
      - 3093:3306
    volumes:
      #- ./data:/docker-entrypoint-initdb.d
      - node-mysql:/var/lib/mysql
      #- ./my-custom.cnf:/etc/mysql/conf.d/my-custom.cnf

  # CONTENEDOR PARA NODEJS
  back:
    # con el . indico que el archivo dockerfile para construir está en la misma carpeta del docker-compose
    build: .
    image: back-sidecc-ddo:v1
    container_name: back-app-sidecc-ddo
    hostname: back-app-sidecc-ddo
    env_file:
      - ./.env
    ports:
      # SO ANFITRIÓN : CONTENEDOR
      #- $NODE_LOCAL_PORT:$NODE_DOCKER_PORT
      - 3090:3090
    environment:
      # Variables de entorno para que la app Node se conecte a la DB
      DB_HOST: mysqldb
      DB_USER: root
      DB_PASSWORD: ${MYSQLDB_PASSWORD} #coincidir con la de MYSQL_ROOT_PASSWORD
      DB_NAME: ${MYSQLDB_DATABASE}
      PORT: 3000 #Puerto donde escucha docker (está bien)
    depends_on:
      - mysqldb

volumes:
  node-mysql:

#docker-compose genera los contenedores
#docker compose up //Ejecuta el archivo .yml y construye los contenedores
#al usar nuevamente docker compose up (luego de parar todo) utiliza los contenedores que ya había creado anteriormente

#docker compose down
#elimina todos los contenedores y redes que se crearon, agregar '--rmi all' para eliminar también las imágenes

#docker-compose down -v //elimina los volumenes

#docker compose up --build (build forzará la construcción de las imágenes, para cuando se haga cambios en el código nodejs)